name: gaming-master

x-health-postgres: &health_postgres
  test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-appdb} -h localhost -p 5432"]
  interval: 5s
  timeout: 3s
  retries: 20
  start_period: 10s

x-health-tcp: &health_tcp
  test: ["CMD-SHELL", "nc -z localhost $${HEALTH_PORT:-8080} || exit 1"]
  interval: 10s
  timeout: 5s
  retries: 20
  start_period: 20s

##############################
# NETWORKS & VOLUMES
##############################
networks:
  kafkanet:
    external: true
    name: docker_kafkanet
    driver: bridge
  web:
    external: true
    name: docker_web
    driver: bridge

volumes:
  pgdata:
  pgadmin_data:
  kfkdata:
  zk-data:
  zk-logs:

##############################
# SERVICES
##############################
services:
  # ==========================
  # Infra: PostgreSQL
  # ==========================
  postgres:
    profiles: ["infra", "bootstrap", "app"]
    image: postgres:16
    container_name: postgres
    restart: unless-stopped

    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      TZ: Asia/Bangkok

    ports: ["5432:5432"]
    healthcheck: *health_postgres
    volumes:
      - pgdata:/var/lib/postgresql/data

    networks: [web]

  # ==========================
  # Infra: pgAdmin
  # ==========================
  pgadmin:
    profiles: ["infra", "bootstrap"]
    image: dpage/pgadmin4:latest
    container_name: pgadmin
    restart: unless-stopped

    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD}
      PGADMIN_LISTEN_PORT: 6000
      TZ: Asia/Bangkok
    ports: ["5050:6000"]
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    depends_on:
      postgres:
          condition: service_healthy
    networks: [web]

  # ==========================
  # Infra: Zookeeper
  # ==========================
  zookeeper:
    profiles: ["infra", "app"]
    image: confluentinc/cp-zookeeper:7.5.0
    container_name: zookeeper
    restart: unless-stopped

    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
      ZOOKEEPER_SYNC_LIMIT: 2
      ZOOKEEPER_INIT_LIMIT: 10
      KAFKA_OPTS: "-Dzookeeper.4lw.commands.whitelist=ruok,stat,srvr,mntr,conf"
    ports:
      - "2181:2181"
    volumes:
      - zk-data:/var/lib/zookeeper/data
      - zk-logs:/var/lib/zookeeper/log
    healthcheck:
      test: ["CMD-SHELL", "echo ruok | nc -w 2 127.0.0.1 2181 | grep -q imok"]
      interval: 10s
      timeout: 5s
      retries: 20
      start_period: 20s
    networks: [kafkanet]

  # ==========================
  # Infra: Kafka
  # ==========================
  kafka:
    profiles: ["infra", "app"]
    image: confluentinc/cp-kafka:7.5.0
    container_name: kafka
    restart: unless-stopped
    depends_on:
      zookeeper:
        condition: service_healthy
    networks: [kafkanet, web]
    ports:
      - "9092:9092"
    volumes:
      - kfkdata:/var/lib/kafka/data
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092,PLAINTEXT_INTERNAL://0.0.0.0:29092
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://${KAFKA_EXTERNAL_IP:-18.142.185.25}:9092,PLAINTEXT_INTERNAL://kafka:29092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_INTERNAL:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT_INTERNAL
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      KAFKA_MIN_INSYNC_REPLICAS: 1
      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0

    healthcheck:
      test: ["CMD-SHELL", "nc -z localhost 9092 || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 20
      start_period: 30s


  # ==========================
  # Infra: Kafdrop (Kafka UI)
  # ==========================
  kafdrop:
    profiles: ["infra"]
    image: obsidiandynamics/kafdrop:4.0.2
    container_name: kafdrop
    restart: unless-stopped

    environment:
      KAFKA_BROKERCONNECT: kafka:29092
      JVM_OPTS: "-Xms32M -Xmx64M"
    ports:
      - "9000:9000"
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:9000 | grep -q '<title>Kafdrop'"]
      interval: 10s
      timeout: 5s
      retries: 12
      start_period: 20s
    depends_on:
      kafka:
        condition: service_healthy
    networks: [kafkanet, web]
  
  
  # ===========================================================
  # BOOTSTRAP / SEED (profiles: bootstrap)
  # ===========================================================
  db-bootstrapper:
    profiles: ["bootstrap"]
    image: postgres:16
    depends_on:
      postgres:
        condition: service_healthy

    environment:
      POSTGRES_HOST: postgres
      POSTGRES_PORT: "5432"
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      PGPASSWORD: ${POSTGRES_PASSWORD}
    working_dir: /work
    volumes:
      - ./schema:/work/schema:ro

    entrypoint: [ "bash", "-lc" ]
    command: >
          "
          set -e;
          echo '>> Applying schema...';
          psql -h postgres -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-appdb} -f schema/00-init.sql;
          psql -h postgres -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-appdb} -f schema/10-tables.sql;
          psql -h postgres -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-appdb} -f schema/20-seed.sql;
          echo '>> Seed completed';
          "
    networks: [web]
  # ==========================
  # App: Discovery Service (Eureka)
  # ==========================
  discoveryservice:
    profiles: ["app"]
    build:
      context: ../backend/discoveryserver
      dockerfile: Dockerfile
    container_name: discoveryservice
    restart: unless-stopped
    networks: [web]
    ports:
      - "5002:5002"
    environment:
      SERVER_PORT: "5002"
      SPRING_PROFILES_ACTIVE: "dev"
      USER_NAME: "admin"
      PASSWORD: "letmein"
    healthcheck:
      test: ["CMD-SHELL", "exit 0"]
      interval: 10s
      timeout: 5s
      retries: 12
      start_period: 20s



  # ==========================
  # App: Authorization Server
  # ==========================
  authorizationserver:
    profiles: ["app"]
    build:
      context: ../backend/authorizationserver
      dockerfile: Dockerfile
    container_name: authorizationserver
    restart: unless-stopped
    depends_on:
      discoveryservice:
        condition: service_healthy
      postgres:
        condition: service_healthy
    networks: [web]
    ports:
      - "9001:8080"
    environment:
      SERVER_PORT: "8080"
      SPRING_PROFILES_ACTIVE: "dev"
      SPRING_APPLICATION_NAME: "authorizationserver"
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: "http://admin:letmein@discoveryservice:5002/eureka/"
      SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI: "http://authorizationserver:9001/authorization"

      # ใช้ค่าจาก .env
      ISSUER_URI: "${ISSUER_URI}"
      SPRING_DATASOURCE_URL: "jdbc:postgresql://postgres:5432/${LOCAL_POSTGRES_DB}"
      SPRING_DATASOURCE_USERNAME: "${LOCAL_POSTGRES_USER}"
      SPRING_DATASOURCE_PASSWORD: "${LOCAL_POSTGRES_PASSWORD}"
      SPRING_JPA_HIBERNATE_DDL_AUTO: "update"
      SPRING_JPA_SHOW_SQL: "false"
      SPRING_JPA_PROPERTIES_HIBERNATE_DIALECT: "org.hibernate.dialect.PostgreSQLDialect"
      TZ: Asia/Bangkok
      
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:8080/authorization/actuator/health | grep -q '\"status\":\"UP\"'"]
      interval: 10s
      timeout: 5s
      retries: 30
      start_period: 40s

  # ==========================
  # App: User Service
  # ==========================
  userservice:
    profiles: ["app"]
    build:
      context: ../backend/userservice
      dockerfile: Dockerfile
    container_name: userservice
    restart: unless-stopped
    depends_on:
      discoveryservice:
        condition: service_healthy
      authorizationserver:
        condition: service_healthy
      postgres:
        condition: service_healthy
      kafka:
        condition: service_healthy
    networks: [web]
    ports:
      - "8085:8085"
    environment:
      SPRING_PROFILES_ACTIVE: "dev"
      SERVER_PORT: "8085"
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: "http://admin:letmein@discoveryservice:5002/eureka/"

      # sync กับ .env
      SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI: "${ISSUER_URI}"

      SPRING_DATASOURCE_URL: "jdbc:postgresql://postgres:5432/${LOCAL_POSTGRES_DB}"
      SPRING_DATASOURCE_USERNAME: "${LOCAL_POSTGRES_USER}"
      SPRING_DATASOURCE_PASSWORD: "${LOCAL_POSTGRES_PASSWORD}"

      KAFKA_SERVER_URL: "kafka:29092"
      UI_APP_URL: ${UI_APP_URL}
      JWKS_URI: "http://18.142.185.25:9001/authorization/oauth2/jwks"
      TZ: Asia/Bangkok

    healthcheck:
      test: ["CMD-SHELL", "exit 0"]
      interval: 10s
      timeout: 5s
      retries: 12
      start_period: 30s

  # ==========================
  # App: Ticket Service
  # ==========================
  ticketservice:
    profiles: ["app"]
    build:
      context: ../backend/ticketservice
      dockerfile: Dockerfile
    container_name: ticketservice
    restart: unless-stopped
    depends_on:
      discoveryservice:
        condition: service_healthy
      authorizationserver:
        condition: service_healthy
      postgres:
        condition: service_healthy
      kafka:
        condition: service_healthy
    networks: [web]
    ports:
      - "8086:8086"
    environment:
      SPRING_PROFILES_ACTIVE: "dev"
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: "http://admin:letmein@discoveryservice:5002/eureka/"

      UI_APP_URL: ${UI_APP_URL}

      # DB
      SPRING_DATASOURCE_URL: "jdbc:postgresql://postgres:5432/${LOCAL_POSTGRES_DB}"
      SPRING_DATASOURCE_USERNAME: "${LOCAL_POSTGRES_USER}"
      SPRING_DATASOURCE_PASSWORD: "${LOCAL_POSTGRES_PASSWORD}"

      # Kafka
      KAFKA_SERVER_URL: "kafka:9092"

      # ใช้ internal issuer (ต้อง match กับ iss ของ Authorization Server)
      # sync กับ .env
      SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI: "${ISSUER_URI}"

      TZ: Asia/Bangkok

    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:8086/actuator/health | grep -q '\"status\":\"UP\"'"]
      interval: 10s
      timeout: 5s
      retries: 12
      start_period: 40s


  # ==========================
  # App: Notification Service (Kafka consumer)
  # ==========================
  notificationservice:
    profiles: ["app"]
    build:
      context: ../backend/notificationservice
      dockerfile: Dockerfile
    container_name: notificationservice
    restart: unless-stopped
    depends_on:
      discoveryservice:
        condition: service_healthy
      authorizationserver:
        condition: service_healthy
      postgres:
        condition: service_healthy
      kafka:
        condition: service_healthy
    networks: [web]
    ports:
      - "9013:9013"
    environment:
      SPRING_PROFILES_ACTIVE: "dev"
      SERVER_PORT: "9013"
      SPRING_APPLICATION_NAME: "notificationservice"
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: "http://admin:letmein@discoveryservice:5002/eureka/"
      
      # sync กับ .env
      SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI: "${ISSUER_URI}"
      KAFKA_SERVER_URL: "kafka:29092"
      NOTIFICATION_TOPIC: "NOTIFICATION_TOPIC"
      POSTGRES_HOST: "postgres"
      POSTGRES_PORT: "5432"
      POSTGRES_DB: "${LOCAL_POSTGRES_DB}"
      POSTGRES_USERNAME: "${LOCAL_POSTGRES_USER}"
      POSTGRES_PASSWORD: "${LOCAL_POSTGRES_PASSWORD}"
      TZ: Asia/Bangkok
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:9013/actuator/health | grep -q '\"status\":\"UP\"'"]
      interval: 10s
      timeout: 5s
      retries: 12
      start_period: 30s

  # ==========================
  # App: API Gateway
  # ==========================
  gateway:
    profiles: ["app"]
    build:
      context: ../backend/gateway
      dockerfile: Dockerfile
    container_name: gateway
    restart: unless-stopped
    depends_on:
      discoveryservice:
        condition: service_healthy
      authorizationserver:
        condition: service_healthy
    networks: [web]
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: "dev"
      SERVER_PORT: "8080"
      SPRING_APPLICATION_NAME: "gateway"

      # Eureka
      EUREKA_CLIENT_SERVICEURL_DEFAULTZONE: "http://admin:letmein@discoveryservice:5002/eureka/"
      EUREKA_HOSTNAME: "gateway"

      # ✅ sync
      SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI: "${ISSUER_URI}"
      ISSUER_URI: "${ISSUER_URI}"

      TZ: Asia/Bangkok
    healthcheck:
      test: ["CMD-SHELL", "curl -sf http://localhost:8080/actuator/health | grep -q '\"status\":\"UP\"'"]
      interval: 10s
      timeout: 5s
      retries: 12
      start_period: 30s

  # ==========================
  # App: Frontend SSR (Angular)
  # ==========================
  frontend-ssr:
    profiles: ["app"]
    build:
      context: ../frontend/frontend-gaming-master-public
      dockerfile: Dockerfile
    container_name: frontend-ssr
    restart: always
    networks: [web]
    ports:
      - "4000:4000"

  # ==========================
  # App: Frontend Internal (Static SPA)
  # ==========================
  frontend-internal:
    profiles: ["app"]
    build:
      context: ../frontend/frontend-gaming-master-internal
      dockerfile: Dockerfile
    container_name: frontend-internal
    restart: always
    networks: [web]
    ports:
      - "5000:80"

  # ==========================
  # App: Ticket App (SPA)
  # ==========================
  ticketapp:
    profiles: ["app"]
    build:
      context: ../frontend/ticketapp
      dockerfile: Dockerfile
      args:
        CONFIG: production
    container_name: ticketapp
    restart: unless-stopped
    networks: [web]
    ports:
      - "3001:80"
      - "3003:3003"

  # ==========================
  # App: RTMP Live Stream Server
  # ==========================
  backend-live-api:
    profiles: ["app"]
    build:
      context: ../backend/backend-gaming-master-live-api
      dockerfile: Dockerfile
    container_name: backend-live-api
    restart: always
    networks: [web]
    ports:
      - "1935:1935"
      - "8082:8080"
      - "3000:3000"

  # ==========================
  # App: Nginx Reverse Proxy
  # ==========================
  nginx:
    profiles: ["app"]
    image: nginx:alpine
    container_name: nginx
    restart: always
    networks: [web]
    depends_on:
      - frontend-ssr
      - frontend-internal
    ports:
      - "80:80"
    volumes:
      - ./nginx/sites-available:/etc/nginx/conf.d
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf


# ลำดับการ RUN (ชัดเจนทีละเฟส)

# 1. INFRA ก่อน
# docker compose --profile infra up -d --build
# docker compose up -d --no-deps --build pgadmin
# docker compose ps

# 2. BOOTSTRAP (หนึ่ง-ช็อต)
# docker compose --profile bootstrap up --build --abort-on-container-exit db-bootstrapper
# # รันจบแล้ว container db-seed จะ exit 0 (สำเร็จ)

# 3. APP
# docker compose --profile app up -d --build
# docker compose ps


## ถ้าจะ reset ข้อมูล (dev):
## docker compose down -v
## docker volume rm gaming-master_pgdata